{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { getExtremumX as getBarExtremumX, getExtremumY as getBarExtremumY } from '../BarChart/extremums';\nimport { getExtremumX as getScatterExtremumX, getExtremumY as getScatterExtremumY } from '../ScatterChart/extremums';\nimport { getExtremumX as getLineExtremumX, getExtremumY as getLineExtremumY } from '../LineChart/extremums';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { DrawingContext } from './DrawingProvider';\nimport { SeriesContext } from './SeriesContextProvider';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\n\n// TODO: those might be better placed in a distinct file\nconst xExtremumGetters = {\n  bar: getBarExtremumX,\n  scatter: getScatterExtremumX,\n  line: getLineExtremumX\n};\nconst yExtremumGetters = {\n  bar: getBarExtremumY,\n  scatter: getScatterExtremumY,\n  line: getLineExtremumY\n};\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    children\n  } = props;\n  const formattedSeries = React.useContext(SeriesContext);\n  const drawingArea = React.useContext(DrawingContext);\n  const xAxis = React.useMemo(() => inXAxis === null || inXAxis === void 0 ? void 0 : inXAxis.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis === null || inYAxis === void 0 ? void 0 : inYAxis.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    var _xAxis$map, _yAxis$map;\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      var _formattedSeries$char, _formattedSeries$char2;\n      const getter = getters[chartType];\n      const series = (_formattedSeries$char = (_formattedSeries$char2 = formattedSeries[chartType]) === null || _formattedSeries$char2 === void 0 ? void 0 : _formattedSeries$char2.series) !== null && _formattedSeries$char !== void 0 ? _formattedSeries$char : {};\n      const [minChartTypeData, maxChartTypeData] = getter({\n        series,\n        axis,\n        isDefaultAxis\n      });\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...((_xAxis$map = xAxis === null || xAxis === void 0 ? void 0 : xAxis.map((axis, index) => _extends({\n      id: \"defaultized-x-axis-\".concat(index)\n    }, axis))) !== null && _xAxis$map !== void 0 ? _xAxis$map : []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === DEFAULT_X_AXIS_KEY;\n    }) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      var _axis$scaleType, _axis$min, _axis$max, _axis$min2, _axis$max2;\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        var _axis$categoryGapRati, _axis$barGapRatio;\n        const categoryGapRatio = (_axis$categoryGapRati = axis.categoryGapRatio) !== null && _axis$categoryGapRati !== void 0 ? _axis$categoryGapRati : DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = (_axis$barGapRatio = axis.barGapRatio) !== null && _axis$barGapRatio !== void 0 ? _axis$barGapRatio : DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = (_axis$scaleType = axis.scaleType) !== null && _axis$scaleType !== void 0 ? _axis$scaleType : 'linear';\n      const extremums = [(_axis$min = axis.min) !== null && _axis$min !== void 0 ? _axis$min : minData, (_axis$max = axis.max) !== null && _axis$max !== void 0 ? _axis$max : maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [(_axis$min2 = axis.min) !== null && _axis$min2 !== void 0 ? _axis$min2 : niceDomain[0], (_axis$max2 = axis.max) !== null && _axis$max2 !== void 0 ? _axis$max2 : niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber\n      });\n    });\n    const allYAxis = [...((_yAxis$map = yAxis === null || yAxis === void 0 ? void 0 : yAxis.map((axis, index) => _extends({\n      id: \"defaultized-y-axis-\".concat(index)\n    }, axis))) !== null && _yAxis$map !== void 0 ? _yAxis$map : []), ...(yAxis === undefined || yAxis.findIndex(_ref2 => {\n      let {\n        id\n      } = _ref2;\n      return id === DEFAULT_Y_AXIS_KEY;\n    }) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      var _axis$scaleType2, _axis$min3, _axis$max3, _axis$min4, _axis$max4;\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        var _axis$categoryGapRati2;\n        const categoryGapRatio = (_axis$categoryGapRati2 = axis.categoryGapRatio) !== null && _axis$categoryGapRati2 !== void 0 ? _axis$categoryGapRati2 : DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = (_axis$scaleType2 = axis.scaleType) !== null && _axis$scaleType2 !== void 0 ? _axis$scaleType2 : 'linear';\n      const extremums = [(_axis$min3 = axis.min) !== null && _axis$min3 !== void 0 ? _axis$min3 : minData, (_axis$max3 = axis.max) !== null && _axis$max3 !== void 0 ? _axis$max3 : maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [(_axis$min4 = axis.min) !== null && _axis$min4 !== void 0 ? _axis$min4 : niceDomain[0], (_axis$max4 = axis.max) !== null && _axis$max4 !== void 0 ? _axis$max4 : niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(_ref3 => {\n        let {\n          id\n        } = _ref3;\n        return id;\n      }),\n      yAxisIds: allYAxis.map(_ref4 => {\n        let {\n          id\n        } = _ref4;\n        return id;\n      })\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, yAxis]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };","map":{"version":3,"names":["_extends","React","scaleBand","scalePoint","getExtremumX","getBarExtremumX","getExtremumY","getBarExtremumY","getScatterExtremumX","getScatterExtremumY","getLineExtremumX","getLineExtremumY","isBandScaleConfig","isPointScaleConfig","getScale","DrawingContext","SeriesContext","DEFAULT_X_AXIS_KEY","DEFAULT_Y_AXIS_KEY","getTickNumber","jsx","_jsx","DEFAULT_CATEGORY_GAP_RATIO","DEFAULT_BAR_GAP_RATIO","xExtremumGetters","bar","scatter","line","yExtremumGetters","CartesianContext","createContext","xAxis","yAxis","xAxisIds","yAxisIds","process","env","NODE_ENV","displayName","CartesianContextProvider","props","inXAxis","inYAxis","dataset","children","formattedSeries","useContext","drawingArea","useMemo","map","axisConfig","dataKey","undefined","data","Error","d","value","_xAxis$map","_yAxis$map","axisExtremumCallback","acc","chartType","axis","getters","isDefaultAxis","_formattedSeries$char","_formattedSeries$char2","getter","series","minChartTypeData","maxChartTypeData","minData","maxData","Math","min","max","getAxisExtremum","charTypes","Object","keys","reduce","charType","allXAxis","index","id","concat","findIndex","_ref","scaleType","completedXAxis","forEach","axisIndex","_axis$scaleType","_axis$min","_axis$max","_axis$min2","_axis$max2","range","reverse","left","width","_axis$categoryGapRati","_axis$barGapRatio","categoryGapRatio","barGapRatio","scale","paddingInner","paddingOuter","tickNumber","length","extremums","domain","niceScale","nice","niceDomain","allYAxis","_ref2","completedYAxis","_axis$scaleType2","_axis$min3","_axis$max3","_axis$min4","_axis$max4","top","height","_axis$categoryGapRati2","_ref3","_ref4","Provider"],"sources":["C:/Users/Kenneth/Documents/GitHub/JSDex.github.io/node_modules/@mui/x-charts/esm/context/CartesianContextProvider.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { getExtremumX as getBarExtremumX, getExtremumY as getBarExtremumY } from '../BarChart/extremums';\nimport { getExtremumX as getScatterExtremumX, getExtremumY as getScatterExtremumY } from '../ScatterChart/extremums';\nimport { getExtremumX as getLineExtremumX, getExtremumY as getLineExtremumY } from '../LineChart/extremums';\nimport { isBandScaleConfig, isPointScaleConfig } from '../models/axis';\nimport { getScale } from '../internals/getScale';\nimport { DrawingContext } from './DrawingProvider';\nimport { SeriesContext } from './SeriesContextProvider';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from '../constants';\nimport { getTickNumber } from '../hooks/useTicks';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\n\n// TODO: those might be better placed in a distinct file\nconst xExtremumGetters = {\n  bar: getBarExtremumX,\n  scatter: getScatterExtremumX,\n  line: getLineExtremumX\n};\nconst yExtremumGetters = {\n  bar: getBarExtremumY,\n  scatter: getScatterExtremumY,\n  line: getLineExtremumY\n};\nexport const CartesianContext = /*#__PURE__*/React.createContext({\n  xAxis: {},\n  yAxis: {},\n  xAxisIds: [],\n  yAxisIds: []\n});\nif (process.env.NODE_ENV !== 'production') {\n  CartesianContext.displayName = 'CartesianContext';\n}\nfunction CartesianContextProvider(props) {\n  const {\n    xAxis: inXAxis,\n    yAxis: inYAxis,\n    dataset,\n    children\n  } = props;\n  const formattedSeries = React.useContext(SeriesContext);\n  const drawingArea = React.useContext(DrawingContext);\n  const xAxis = React.useMemo(() => inXAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inXAxis, dataset]);\n  const yAxis = React.useMemo(() => inYAxis?.map(axisConfig => {\n    const dataKey = axisConfig.dataKey;\n    if (dataKey === undefined || axisConfig.data !== undefined) {\n      return axisConfig;\n    }\n    if (dataset === undefined) {\n      throw Error('MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.');\n    }\n    return _extends({}, axisConfig, {\n      data: dataset.map(d => d[dataKey])\n    });\n  }), [inYAxis, dataset]);\n  const value = React.useMemo(() => {\n    const axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis) => {\n      const getter = getters[chartType];\n      const series = formattedSeries[chartType]?.series ?? {};\n      const [minChartTypeData, maxChartTypeData] = getter({\n        series,\n        axis,\n        isDefaultAxis\n      });\n      const [minData, maxData] = acc;\n      if (minData === null || maxData === null) {\n        return [minChartTypeData, maxChartTypeData];\n      }\n      if (minChartTypeData === null || maxChartTypeData === null) {\n        return [minData, maxData];\n      }\n      return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];\n    };\n    const getAxisExtremum = (axis, getters, isDefaultAxis) => {\n      const charTypes = Object.keys(getters);\n      return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis), [null, null]);\n    };\n    const allXAxis = [...(xAxis?.map((axis, index) => _extends({\n      id: `defaultized-x-axis-${index}`\n    }, axis)) ?? []),\n    // Allows to specify an axis with id=DEFAULT_X_AXIS_KEY\n    ...(xAxis === undefined || xAxis.findIndex(({\n      id\n    }) => id === DEFAULT_X_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_X_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedXAxis = {};\n    allXAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, xExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.left + drawingArea.width, drawingArea.left] : [drawingArea.left, drawingArea.left + drawingArea.width];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completedXAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio\n        }, axis, {\n          scale: scaleBand(axis.data, range).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedXAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, range),\n          tickNumber: axis.data.length\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedXAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber\n      });\n    });\n    const allYAxis = [...(yAxis?.map((axis, index) => _extends({\n      id: `defaultized-y-axis-${index}`\n    }, axis)) ?? []), ...(yAxis === undefined || yAxis.findIndex(({\n      id\n    }) => id === DEFAULT_Y_AXIS_KEY) === -1 ? [{\n      id: DEFAULT_Y_AXIS_KEY,\n      scaleType: 'linear'\n    }] : [])];\n    const completedYAxis = {};\n    allYAxis.forEach((axis, axisIndex) => {\n      const isDefaultAxis = axisIndex === 0;\n      const [minData, maxData] = getAxisExtremum(axis, yExtremumGetters, isDefaultAxis);\n      const range = axis.reverse ? [drawingArea.top, drawingArea.top + drawingArea.height] : [drawingArea.top + drawingArea.height, drawingArea.top];\n      if (isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        completedYAxis[axis.id] = _extends({\n          categoryGapRatio,\n          barGapRatio: 0\n        }, axis, {\n          scale: scaleBand(axis.data, [range[1], range[0]]).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),\n          tickNumber: axis.data.length\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completedYAxis[axis.id] = _extends({}, axis, {\n          scale: scalePoint(axis.data, [range[1], range[0]]),\n          tickNumber: axis.data.length\n        });\n      }\n      if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n        // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n        return;\n      }\n      const scaleType = axis.scaleType ?? 'linear';\n      const extremums = [axis.min ?? minData, axis.max ?? maxData];\n      const tickNumber = getTickNumber(_extends({}, axis, {\n        range,\n        domain: extremums\n      }));\n      const niceScale = getScale(scaleType, extremums, range).nice(tickNumber);\n      const niceDomain = niceScale.domain();\n      const domain = [axis.min ?? niceDomain[0], axis.max ?? niceDomain[1]];\n      completedYAxis[axis.id] = _extends({}, axis, {\n        scaleType,\n        scale: niceScale.domain(domain),\n        tickNumber\n      });\n    });\n    return {\n      xAxis: completedXAxis,\n      yAxis: completedYAxis,\n      xAxisIds: allXAxis.map(({\n        id\n      }) => id),\n      yAxisIds: allYAxis.map(({\n        id\n      }) => id)\n    };\n  }, [drawingArea.height, drawingArea.left, drawingArea.top, drawingArea.width, formattedSeries, xAxis, yAxis]);\n\n  // @ts-ignore\n  return /*#__PURE__*/_jsx(CartesianContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { CartesianContextProvider };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}